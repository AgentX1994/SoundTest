use lazy_static::lazy_static;
const DEFAULT_TABLE_SIZE: usize = 256;

lazy_static! {
    pub static ref SAW_WAVE_TABLE: WaveTable = {
        let mut array = [0.0; DEFAULT_TABLE_SIZE];

        let half_table_size = DEFAULT_TABLE_SIZE as f64 / 2.0;
        for i in 0..DEFAULT_TABLE_SIZE {
            array[i] = i as f64 / half_table_size - 1.0;
        }

        WaveTable {
            table: array.to_vec(),
        }
    };
}

/// A Wave Table based
#[derive(Clone, Debug, Default)]
pub struct WaveTable {
    pub table: Vec<f64>,
}

/// A Wave Table oscillator
#[derive(Clone, Debug, Default)]
pub struct WaveTableOscillator {
    /// frequency generated by this oscillator
    frequency: f64,
    /// Sample rate of the audio stream
    sample_rate: u64,
    /// Current index into wave table
    index: f64,
    /// amount to move every sample
    delta: f64,
    /// the wave table
    table: WaveTable,
}

impl WaveTableOscillator {
    pub fn new(frequency: f64, sample_rate: u64, table: WaveTable) -> Self {
        let mut s = Self::default();
        s.cook_frequency(frequency, sample_rate, table.table.len());
        s.index = 0.0;
        s.table = table;
        s
    }

    pub fn set_frequency(&mut self, frequency: f64) {
        self.cook_frequency(frequency, self.sample_rate, self.table.table.len());
    }

    pub fn get_frequency(&self) -> f64 {
        self.frequency
    }

    pub fn set_sample_rate(&mut self, sample_rate: u64) {
        self.cook_frequency(self.frequency, sample_rate, self.table.table.len());
    }

    pub fn get_sample_rate(&self) -> u64 {
        self.sample_rate
    }

    fn cook_frequency(&mut self, frequency: f64, sample_rate: u64, table_size: usize) {
        self.sample_rate = sample_rate;
        self.frequency = frequency;
        self.delta = frequency * (table_size as f64 / sample_rate as f64);
    }

    pub fn step(&mut self) -> f64 {
        let index0 = self.index as usize;
        let index1 = if index0 == self.table.table.len() - 1 {
            0
        } else {
            index0 + 1
        };

        let frac = self.index - index0 as f64;

        let sample =
            self.table.table[index0] + frac * (self.table.table[index1] - self.table.table[index0]);

        self.index += self.delta;
        if self.index >= self.table.table.len() as f64 {
            self.index -= self.table.table.len() as f64;
        }

        sample
    }
}
